var d3 = require('d3'), 
jsdom = require('jsdom'),
logger=require('logger'),
controller =require('controller'),
colorer= require("colorbrewer"),
dataviz='<div id="dataviz-container"></div>';

//---------------------/todo---------------------------------------------------
//---------------------/todo---------------------------------------------------
//---------------------/todo---------------------------------------------------

module.exports={
	chart : function(objectResult, data_marimekko,var_width,var_height,var_margin,res) {
			jsdom.env(
				dataviz,
				function(errors, window) {
					var width = var_width,
					    height = var_height,
					    margin = var_margin;

					var x = d3.scale.linear()
					    .range([0, width - 3 * margin]);

					var y = d3.scale.linear()
					    .range([0, height - 2 * margin]);

					data=data_marimekko;
					var color = d3.scale.quantile().range(d3.range(8));
					domain=[]
					for (i in data) domain.push(parseFloat(data[i].FeatureWeight));
					color.domain(domain);
					color_list=colorer.brewer.RdYlGn[9];
					if (color_list[8] != '#d73027')
						color_list=color_list.reverse();
					color.range(color_list);


					function wrap( d ,size) {
		                var self = d,
		                	limit=size/7;
		                    textLength = self.length,
		                    original=self.length,
		                    text = self;
		                while ( ( textLength > limit )&& text.length > 0) {
		                    text = text.slice(0, -1);
		                    self=text;
		                    textLength = self.length;
		                }
		                if (original > limit)
		                    	self=self+ '...';
						return self;
		            }
					var offset = 0;

					// Nest values by segment. We assume each segment+market is unique.
					var segments = d3.nest()
					  .key(function(d) { return d.cluster; })
					  .entries(data);


					var n = d3.format(",d"),
					    p = d3.format("%");
					var el = window.document.querySelector('#dataviz-container');


					width=width-4*margin;
				  	var svg = d3.select(el).append("svg")
					    .attr("width", width+2.4*margin+1)
					    .attr("height", 80 + margin)
					  .append("g")
					    .attr("transform", "translate(" + 1.3 * margin + "," + margin + ")");

					var legend = svg.selectAll(".legend")
					  .data(color.range())
					  .enter().append("g")
					  .attr("class", "legend")
					  .attr("transform", function(d,i) { return "translate(" + i* (width / color.range().length) + ")"; });
					legend = svg.selectAll(".legend").append("rect")
				      .attr("height", 25)
				      .attr("width", function(d) { return width / color.range().length; })
				      .style("fill", function(d) { return d+";stroke-width:1px;stroke:rgb(0,0,0);fill-opacity: 0.3;" });

				    var xtick = svg.selectAll(".x-legend") // .x can be replaced by blbl, it doesn't matter because no ".x" nodes exist
					  .data(x.ticks(8)) //Number of ticks, 
					.enter().append("g") // enter allows to create nodes "g" for each data 
					  .attr("class", "x-legend") // nodes g will be of class x
					  .attr("transform", function(d,i) { return "translate(" + i* (width / color.range().length)+",25)"; }); //y(1) ?

					//Tick lines
					xtick.append("line")
					  .attr("y2", 5)
					  .style("stroke", "#000");

					xtick.append("text")
					  .attr("y", 8)
					  .attr("text-anchor", "middle")
					  .attr("dy", ".71em")
					  .attr("font-size", "12px")
					  .text(function(d,i) {
					  		if (i == 0 )
					  			return Math.min.apply(Math, domain).toFixed(1);
					  		if (i == color.range().length)
					  			return Math.max.apply(Math, domain).toFixed(1);
					  		var num=new Number(color.quantiles()[i - 1]);
			             	return num.toFixed(1);
			           });

					//------------------Marimekko-------------------

					width = var_width;

					var svg = d3.select(el).append("svg")
					    .attr("preserveAspectRatio", "xMinYMin meet")
						 .attr("viewBox", "0 0 "+(width + var_margin)+" "+(height+var_margin))
					  .append("g")
					    .attr("transform", "translate(" + 2 * margin + "," + margin /2 + ")");

					

					
					
					var col_width=(width-2*margin)/segments.length;

					// Compute the total sum, the per-segment sum, and the per-market offset.
					// You can use reduce rather than reduceRight to reverse the ordering.
					// We also record a reference to the parent segment for each market.
					var sum = segments.reduce(function(v, p) {
						p.sum=p.values.reduceRight(function(v, d) {
						  d.parent = p;
						  return (d.offset = v) + parseFloat(d.FeatureWeight);
						},0);
						return (p.offset = v) + 10;
					}, 0);

					// Add y-axis ticks.
					var ytick = svg.selectAll(".y")
					  .data(y.ticks(10))
					.enter().append("g")
					  .attr("class", "y")
					  .attr("transform", function(d) { return "translate(0," + y(1 - d) + ")"; });

					ytick.append("line")
					  .attr("x1", -5)
					  .style("stroke", "#000");

					ytick.append("text")
					  .attr("x", -8)
					  .attr("text-anchor", "end")
					  .attr("dy", ".35em")
					  .attr("font-size", "14px")
					  .text(p);

					

					// Add a group for each segment.
					var segments = svg.selectAll(".cluster")
					  .data(segments)
					.enter().append("g")
					  .attr("class", "cluster")
					  .attr("xlink:title", function(d) { return d.key; })
					  .attr("transform", function(d, i) { return "translate("+i*col_width+",0)"; });

					// Add a rect for each market.
					var markets = segments.selectAll(".feature")
					  .data(function(d) { return d.values; })
					.enter().append("g").attr("class", "feature-desc")

				    

				    markets.append("rect")
				      .attr("y", function(d) { return y(d.offset / d.parent.sum); })
				      .attr("height", function(d) { return y(parseFloat(d.FeatureWeight) / d.parent.sum); })
				      .attr("width", function(d) { return col_width; })
				      .style("fill", function(d) { return color(parseFloat(d.FeatureWeight))+";stroke-width:1px;stroke:rgb(0,0,0);fill-opacity: 0.3;" });

				    segments.selectAll(".feature-desc").append("text").attr("class", "text-desc")
				    	//.attr("font-size", "12px")
				    	.attr("y", function(d) { return y(d.offset / d.parent.sum) + 15; })
				    	.attr("x", function(d) { return d.parent.sum / sum + 4; })
				    	.attr("title", function(d) { return d.FeatureName;  })
				    	.style("font-size","11px")
				    	.text(function(d) { return wrap(d.FeatureName, (col_width -5)); });



				    	var segments = d3.nest()
					  .key(function(d) { return d.cluster; })
					  .entries(data);

				    var xtick = svg.selectAll(".x-legend") // .x can be replaced by blbl, it doesn't matter because no ".x" nodes exist
					  .data(segments) //Number of ticks, 
					.enter().append("g") // enter allows to create nodes "g" for each data 
					  .attr("class", "x-legend") // nodes g will be of class x
					  .attr("transform", function(d,i) { return "translate(" + ((col_width/ 2) + i* col_width) +","+(height - 2*margin)+")"; }); //y(1) ?

					xtick.append("text")
					  .attr("y", 10)
					  .attr("text-anchor", "middle")
					  .attr("dy", ".71em")
					  .attr("font-size", "10px")
					  .text(function(d,i) {
					  		return "Classe " +d.key;
			           });


				   	/*
						Legend 
				   	*/
				   	


				objectResult.svgsrc = window.document.querySelector('#dataviz-container').innerHTML;
				controller.marimekko(res, objectResult);
			}
			);
	}
	
}